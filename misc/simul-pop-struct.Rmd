---
title: "Simulations of population structure"
author: "T. Flutre (INRAE)"
date: "`r format(Sys.time(), '%d/%m/%Y %H:%M:%S')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: TRUE
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: TRUE
urlcolor: blue
---

```{r setup, include=FALSE}
suppressPackageStartupMessages(library(knitr))
opts_chunk$set(echo=TRUE, warning=TRUE, message=TRUE, cache=FALSE,
               fig.align="center", collapse=TRUE)
opts_knit$set(progress=TRUE, verbose=TRUE)
```


# Preamble

Dependencies:
```{r}
suppressPackageStartupMessages(library(bnpsd))
suppressPackageStartupMessages(library(popkin))
suppressPackageStartupMessages(library(scrm))
suppressPackageStartupMessages(library(adegenet))
suppressPackageStartupMessages(library(parallel))
suppressPackageStartupMessages(library(rutilstimflutre))
```

Execution time (see the appendix):
```{r time_0}
t0 <- proc.time()
```



# Simulation with base R only

```{r}
nbGenos <- c(100, 120, 80) # per pop
nbSnps <- 1000
levSnps <- sprintf(fmt=paste0("s%0", floor(log10(nbSnps))+1, "i"),
                   1:nbSnps)

weak.div.pops <- diag(3)
weak.div.pops[upper.tri(weak.div.pops)] <- 0.9
weak.div.pops[lower.tri(weak.div.pops)] <- weak.div.pops[upper.tri(weak.div.pops)]
weak.div.pops
X <- simulGenosDoseStruct(nb.genos=nbGenos, nb.snps=nbSnps, div.pops=weak.div.pops,
                          snp.ids=levSnps)
K <- estimGenRel(X)
imageWithScale(K, "Weak divergence")

strong.div.pops <- diag(3)
strong.div.pops[upper.tri(strong.div.pops)] <- 0.5
strong.div.pops[lower.tri(strong.div.pops)] <- strong.div.pops[upper.tri(strong.div.pops)]
strong.div.pops
X <- simulGenosDoseStruct(nb.genos=nbGenos, nb.snps=nbSnps, div.pops=strong.div.pops,
                          snp.ids=levSnps)
K <- estimGenRel(X)
imageWithScale(K, "Strong divergence")
```



# Simulation with `bnpsd` and `popkin`

See the [vignette](https://cran.r-project.org/web/packages/bnpsd/vignettes/bnpsd.html) of the `bnpsd` package.

```{r}
nbGenos <- 300
levGenos <- sprintf(fmt=paste0("g%0", floor(log10(nbGenos))+1, "i"),
                    1:nbGenos)
nbSnps <- 1000
levSnps <- sprintf(fmt=paste0("s%0", floor(log10(nbSnps))+1, "i"),
                   1:nbSnps)
nbSubPops <- 10
Fst <- 0.1
bias_coeff <- 0.5
```

## Admixture proportions

From 1D geography.

```{r}
admixprops <- admix_prop_1d_linear(
    n_ind = nbGenos,
    k_subpops = nbSubPops,
    bias_coeff = bias_coeff,
    coanc_subpops = 1:nbSubPops,
    fst = Fst)
```

## Pop structure

Parameters of the admixed individuals.

```{r}
coancestries <- coanc_admix(
    admixprops$admix_proportions,
    admixprops$coanc_subpops)
```

```{r, fig.width=12}
## visualize the admixture proportions
op <- par(mar = c(1, 4, 3, 0) + 0.2)
barplot(
    t(admixprops$admix_proportions),
    ## col = col_subpops,
    border = NA,
    space = 0,
    ylab = 'Admixture prop.')
mtext('Genotypes', 1)
par(op)
```

```{r}
## visualize the coancestry matrix
plot_popkin(
    coancestries,
    mar = c(1, 4, 3, 0) + 0.2,
    ## mar = 0, # zero inner margin (plus padding) because we have no labels
    leg_title = 'Coancestry')
```

## SNP genotypes

```{r}
## draw ancestral AFs
p_anc <- draw_p_anc(nbSnps, beta=0.2)
## draw intermediate independent subpopulations AFs
p_subpops <- draw_p_subpops(p_anc, admixprops$coanc_subpops)
## draw individual-specific AFs
p_ind <- make_p_ind_admix(p_subpops, admixprops$admix_proportions)
## draw genotypes
X <- draw_genotypes_admix(p_ind)
colnames(X) <- levGenos
rownames(X) <- levSnps
X <- t(X)

dim(X)
X[1:3,1:4]
table(X)
```

## AFs and MAFs

```{r, fig.width=10}
snpAFs <- estimSnpAf(X)
plotHistAllelFreq(afs=snpAFs)

snpMAFs <- estimSnpMaf(X)
plotHistMinAllelFreq(mafs=snpMAFs)
```

## Genomic relationships

```{r}
K <- estimGenRel(X)
imageWithScale(K)
```



# Simulation with `srcm`

Set up the parallel computations:
```{r}
nb.cores <- max(1, detectCores() - 1)
cl <- makeCluster(spec=nb.cores, type="PSOCK")
RNGkind("L'Ecuyer-CMRG")
clusterSetRNGStream(cl=cl, iseed=1234)
clusterEvalQ(cl, library(adegenet))
```

Simulate genotypic data with no population structure:
```{r}
set.seed(1234)
nb.genos <- 300
Ne <- 10^4
chrom.len <- 10^5
mu <- 10^(-8)
c.rec <- 10^(-8)
genomes.nostruct <- simulCoalescent(nb.inds=nb.genos, nb.reps=10,
                                    pop.mut.rate=4 * Ne * mu * chrom.len,
                                    pop.recomb.rate=4 * Ne * c.rec * chrom.len,
                                    chrom.len=chrom.len,
                                    nb.pops=1,
                                    verbose=1)
dim(genomes.nostruct$genos)
```

Simulate genotypic data with population structure:
```{r}
chrom.lens <- c("high"=10^3, "med"=10^5, "low"=10^5)
mig.rates <- c("high"=10^4, "med"=10,   "low"=0.5)
nb.chroms <- c("high"=1,    "med"=4,    "low"=8)
genomes.struct <- list()
for(i in seq_along(mig.rates)){
  set.seed(1234)
  genomes.struct[[names(mig.rates)[i]]] <- simulCoalescent(nb.inds=nb.genos, nb.reps=nb.chroms[i],
                                                           pop.mut.rate=4 * Ne * mu * chrom.lens[i],
                                                           pop.recomb.rate=4 * Ne * c.rec * chrom.lens[i],
                                                           chrom.len=chrom.lens[i],
                                                           nb.pops=3, mig.rate=mig.rates[i],
                                                           verbose=1)
}
sapply(genomes.struct, function(x){dim(x$genos)})
```

Combine both into a single data set:
```{r}
X.pops <- lapply(names(mig.rates), function(n){
  tmp <- genomes.struct[[n]]$genos
  nb.remain.chrs <- 10 - length(unique(genomes.struct[[n]]$snp.coords[colnames(tmp),"chr"]))
  remain.chrs <- unique(genomes.nostruct$snp.coords[,"chr"])[1:nb.remain.chrs]
  snps.toadd <- rownames(genomes.nostruct$snp.coords[genomes.nostruct$snp.coords$chr %in%
                                                       remain.chrs,])
  X <- cbind(tmp, genomes.nostruct$genos[, snps.toadd])
  colnames(X)[(ncol(tmp)+1):ncol(X)] <- paste0(colnames(X)[(ncol(tmp)+1):ncol(X)],
                                               "_nostruct")
  X
})
names(X.pops) <- names(mig.rates)
sapply(X.pops, dim)
```

```{r}
tmp <- lapply(names(X.pops), function(n){
  A <- estimGenRel(X=X.pops[[n]], verbose=0)
  imageWithScale(A, main=paste0("Additive genetic relationships (migration=", n, ")"))
})
```

```{r}
out.pca <- lapply(X.pops, function(X){
  pca(X=X)
})
sapply(out.pca, function(x){x$prop.vars[1:4]})
tmp <- lapply(names(out.pca), function(x){
  barplot(out.pca[[x]]$prop.vars,
          main=paste0("Proportion of variance explained by each PC (migration=", x, ")"),
          xlim=c(0,10), las=1)
  plotPca(rotation=out.pca[[x]]$rot.dat,
          prop.vars=out.pca[[x]]$prop.vars,
          # cols=c(rep("black", 100), rep("red", 100), rep("green", 100)),
          main=paste0("PC (migration=", x, ")"))
})
```

Need to get the point colors right!
Let's use adegenet for this.

```{r}
genlights <- lapply(X.pops, function(X){
  new("genlight", X)
})
fclusts <- parLapply(cl=cl, genlights, function(gl){
  find.clusters(x=gl, n.pca=100, scale=TRUE, method="kmeans",
                choose.n.clust=TRUE, n.clust=3)
                # stat="BIC", choose.n.clust=FALSE, max.n.clust=7, criterion="min")#smoothNgoesup")
})
sapply(fclusts, function(x){x$size})
# tmp <- lapply(names(fclusts), function(x){
#   plot(fclusts[[x]]$Kstat, xlab="K", ylab="BIC",
#        main=paste0("Choose the number of clusters (migration=", x, ")"))
# })
clusterExport(cl=cl, varlist=c("genlights","fclusts"))
dapc <- parLapply(cl=cl, 1:length(genlights), function(i){
  dapc(x=genlights[[i]], pop=fclusts[[i]]$grp, n.pca=10, n.da=5)
})
names(dapc) <- names(genlights)
tmp <- lapply(names(dapc), function(x){
  print(scatter(x=dapc[[x]],
                sub=paste0("migration=", x), possub="topleft",
                scree.pca=FALSE, scree.da=FALSE))
})
```

```{r}
stopCluster(cl)
```



# Appendix

```{r info}
t1 <- proc.time()
t1 - t0
print(sessionInfo(), locale=FALSE)
```
